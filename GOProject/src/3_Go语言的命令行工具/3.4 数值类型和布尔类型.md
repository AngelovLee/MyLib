> Go语言提供了大量的内置数据类型，每一个数值类型都不同，意味着不能在不同类型之间进行二进制数值运算或者比较操作。无类型的数值常量可以兼容内置的任何类型的数值，在不同类型数值之间进行运算或者比较操作，需要进行类型转换。类型转换采用type(value)的方式，只要合法就能转换成功，即使会导致数据精度丢失。
##### 4.1 整型
```
Go语言提供了11种整型，如下列表所示

类型	说明
byte	等同于uint8
int	依赖于不同平台下的实现，可以是int32或者int64
int8	[-128, 127]
int16	[-32768, 32767]
int32	[-2147483648, 2147483647]
int64	[-9223372036854775808, 9223372036854775807]
rune	等同于uint32
uint	依赖于不同平台下的实现，可以是uint32或者uint64
uint8	[0, 255]
uint16	[0, 65535]
uint32	[0, 4294967295]
uint64	[0, 18446744073709551615]
uintptr	一个可以恰好容纳指针值的无符号整型（对32位平台是uint32, 对64位平台是uint64）
在C语言中我们可以通过sizeof操作符查看类型的字节长度，在Go语言中可以通过unsafe.Sizeof函数进行，使用vim创建源文件type_length.go，输入以下代码：

package main

import (
    "fmt"
    "unsafe"
)

func main() {
    a := 12
    fmt.Println("length of a: ", unsafe.Sizeof(a))
    var b int = 12
    fmt.Println("length of b(int): ", unsafe.Sizeof(b))
    var c int8 = 12
    fmt.Println("length of c(int8): ", unsafe.Sizeof(c))
    var d int16 = 12
    fmt.Println("length of d(int16): ", unsafe.Sizeof(d))
    var e int32 = 12
    fmt.Println("length of e(int32): ", unsafe.Sizeof(e))
    var f int64 = 12
    fmt.Println("length of f(int64): ", unsafe.Sizeof(f))
}
以上代码中，首先声明了目前的源文件属于main包，然后导入了fmt和unsafe包，fmt包用于格式化字符串，unsafe包含了用于获取Go语言类型信息的方法。然后在main函数中，我们分别声明了几种类型的整型变量，并通过unsafe.Sizeof方法获取该类型的字节长度。最后我们通过以下方法运行type_length.go，同时打印出了输出：

$ go run type_length.go 
length of a:  8
length of b(int):  8
length of c(int8):  1
length of d(int16):  2
length of e(int32):  4
length of f(int64):  8
```
##### 4.2 浮点类型
```

Go语言提供了两种浮点类型和两种复数类型, 具体如下：

类型	说明
float32	±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后7个十进制数
float64	±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后15个十进制数
complex32	复数，实部和虚部都是float32
complex64	复数，实部和虚部都是float64
```
##### 4.3 布尔类型
```
Go语言提供了内置的布尔值true和false。Go语言支持标准的逻辑和比较操作，这些操作的结果都是布尔值。值得注意的地方是可以通过!b的方式反转变量b的真假。

```